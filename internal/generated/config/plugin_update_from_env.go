// Code generated by genfig plugin 'update_from_env'; DO NOT EDIT.

package config

import (
	"encoding/json"
	"fmt"
	"os"
	"strconv"
)

var (
	_ = os.LookupEnv
	_ = fmt.Sprintf
	_ = json.Marshal
)

func (c *Config) UpdateFromEnv() []error {
	var val string
	_ = val
	var exists bool
	_ = exists
	var errors = []error{}

	if val, exists = os.LookupEnv("APIPATH"); exists {
		c.Apipath = val
	}

	if val, exists = os.LookupEnv("BASEPATH"); exists {
		c.Basepath = val
	}

	if val, exists = os.LookupEnv("DEBUG"); exists {
		if v, err := parseBool(val); err == nil {
			c.Debug = v
		} else {
			errors = append(errors, fmt.Errorf("Genfig: could not parse bool from CONFIG_DEBUG ('%s')\n", val))
		}
	}

	if val, exists = os.LookupEnv("GREETER_DEFAULTNAME"); exists {
		c.Greeter.DefaultName = val
	}

	if val, exists = os.LookupEnv("GREETER_HELLO"); exists {
		c.Greeter.Hello = val
	}

	if val, exists = os.LookupEnv("GREETER_INAPPROPRIATENAMES"); exists {
		if v, err := parseStringSlice(val); err == nil {
			c.Greeter.InappropriateNames = v
		} else {
			errors = append(errors, fmt.Errorf("Genfig: could not parse []string from CONFIG_GREETER_INAPPROPRIATENAMES ('%s')\n", val))
		}
	}

	if val, exists = os.LookupEnv("GREETER_MAXKNOWNUSERS"); exists {
		if v, err := parseInt64(val); err == nil {
			c.Greeter.MaxKnownUsers = v
		} else {
			errors = append(errors, fmt.Errorf("Genfig: could not parse int64 from CONFIG_GREETER_MAXKNOWNUSERS ('%s')\n", val))
		}
	}

	if val, exists = os.LookupEnv("GRPCPORT"); exists {
		if v, err := parseInt64(val); err == nil {
			c.GrpcPort = v
		} else {
			errors = append(errors, fmt.Errorf("Genfig: could not parse int64 from CONFIG_GRPCPORT ('%s')\n", val))
		}
	}

	if val, exists = os.LookupEnv("HOST"); exists {
		c.Host = val
	}

	if val, exists = os.LookupEnv("PORT"); exists {
		if v, err := parseInt64(val); err == nil {
			c.Port = v
		} else {
			errors = append(errors, fmt.Errorf("Genfig: could not parse int64 from CONFIG_PORT ('%s')\n", val))
		}
	}

	if val, exists = os.LookupEnv("REGISTRY"); exists {
		c.Registry = val
	}

	if val, exists = os.LookupEnv("SERVICE_NAME"); exists {
		c.Service.Name = val
	}

	if val, exists = os.LookupEnv("SERVICE_VERSION"); exists {
		c.Service.Version = val
	}

	if val, exists = os.LookupEnv("SERVICES_STORAGE_ADDR"); exists {
		c.Services.Storage.Addr = val
	}

	if val, exists = os.LookupEnv("TRACE"); exists {
		if v, err := parseBool(val); err == nil {
			c.Trace = v
		} else {
			errors = append(errors, fmt.Errorf("Genfig: could not parse bool from CONFIG_TRACE ('%s')\n", val))
		}
	}

	if val, exists = os.LookupEnv("TRACING_SECRET"); exists {
		c.Tracing.Secret = val
	}

	if val, exists = os.LookupEnv("TRACING_SERVICE"); exists {
		c.Tracing.Service = val
	}

	if val, exists = os.LookupEnv("TRACING_URI"); exists {
		c.Tracing.Uri = val
	}

	if len(errors) == 0 {
		return nil
	} else {
		return errors
	}
}

// these are wrappers, so that they can
// a) be referenced easily be the code generator and
// b) be replaces easily by you (or me)
func parseInt64(s string) (i int64, err error) {
	i, err = strconv.ParseInt(s, 10, 0)
	return
}

func parseFloat64(s string) (f float64, err error) {
	f, err = strconv.ParseFloat(s, 0)
	return
}

func parseBool(s string) (b bool, err error) {
	b, err = strconv.ParseBool(s)
	return
}

func parseStringSlice(s string) (a []string, err error) {
	err = json.Unmarshal([]byte(s), &a)
	return
}

func parseInt64Slice(s string) (a []int64, err error) {
	err = json.Unmarshal([]byte(s), &a)
	return
}

func parseFloat64Slice(s string) (a []float64, err error) {
	err = json.Unmarshal([]byte(s), &a)
	return
}

func parseInterfaceSlice(s string) (a []interface{}, err error) {
	err = json.Unmarshal([]byte(s), &a)
	return
}

func parseMapSlice(s string) (a []map[interface{}]interface{}, err error) {
	err = json.Unmarshal([]byte(s), &a)
	return
}
